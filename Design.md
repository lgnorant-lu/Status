# Status-Ming 设计文档

**项目名称**: Status-Ming
**作者**: lgnorant-lu
**最后更新**: 2025-05-14
**核心技术**: PySide6

## 1. 项目概述与目标

Status-Ming 是一个以猫咪为主题的交互式桌面宠物应用，旨在通过桌宠的视觉状态反馈计算机的核心性能指标。本项目基于PySide6进行UI和核心交互开发。

**当前阶段目标 (MVP - Minimum Viable Product):**
- 实现一个可显示、可拖动的桌宠（使用猫咪占位符图像/动画）。
- 桌宠能够根据核心系统参数（CPU、内存等）改变其状态和动画。
- 提供一个简约的、按需显示的数字化面板，展示具体的系统参数。
- 用户可以通过简单的交互（如右键菜单）关闭应用。

**长期愿景 (Post-MVP):**
- 集成真实的、高质量的猫咪像素动画。
- 丰富桌宠行为与交互，增强个性化和智能化。
- 实现模块化的快捷功能（如快速启动、笔记等）。
- 探索LLM（大型语言模型）集成，赋予桌宠更高级的交互能力。
- 持续优化性能和用户体验。

## 2. MVP 系统架构设计

### 2.1. 核心模块

MVP阶段主要包含以下核心模块：

1.  **`PetWindow` (UI层 - PySide6)**:
    *   **职责**: 作为桌宠应用的主窗口。实现无边框、可设置透明背景、响应鼠标拖拽移动。承载桌宠的渲染区域和可能的交互元素。
    *   **主要交互**: 接收用户输入（拖拽、点击），分发给 `InteractionHandler`。

2.  **`Renderer` (渲染模块 - PySide6集成)**:
    *   **职责**: 负责在 `PetWindow` 上绘制所有视觉内容，包括桌宠的占位符动画帧、以及 `StatsPanel`。
    *   **技术**: 利用PySide6的 `QPainter` API进行高效绘制。管理动画帧的切换和播放。

3.  **`Resources` (资源管理器)**:
    *   **职责**: 加载、管理和提供应用所需的资源，MVP阶段主要是占位符图像 (如PNG序列帧图)。
    *   **交互**: 被 `Renderer` 调用以获取图像数据。

4.  **`SystemMonitor` (系统监控模块)**:
    *   **职责**: 独立、定期地获取关键系统性能参数，如CPU使用率、内存使用率。未来可扩展至GPU、磁盘、网络等。
    *   **技术**: 主要使用 `psutil`库，按需考虑 `GPUtil` 等。
    *   **交互**: 向 `BehaviorLogic` 和 `StatsPanel` 提供数据。

5.  **`BehaviorLogic` (行为逻辑模块)**:
    *   **职责**: 核心决策模块。根据从 `SystemMonitor` 获取的系统数据，决定桌宠当前的逻辑状态（例如 `IDLE`, `ACTIVE_LOW`, `ACTIVE_MEDIUM`, `ACTIVE_HIGH` 等）。
    *   **交互**: 将状态变更通知给 `Renderer`，以便切换到对应的动画。

6.  **`InteractionHandler` (交互处理模块)**:
    *   **职责**: 处理来自 `PetWindow` 的用户输入事件（如鼠标右键点击），并执行相应操作（如显示上下文菜单、触发退出应用等）。
    *   **交互**: 与PySide6的事件系统集成。

7.  **`StatsPanel` (UI层 - PySide6, 可选)**:
    *   **职责**: 一个简约的UI面板，用于显示 `SystemMonitor` 提供的具体系统参数数值。
    *   **特性**: MVP阶段可以设计为按需显示/隐藏（例如通过快捷键或鼠标悬停在特定区域）。可以集成到 `PetWindow` 内或作为独立的浮动小部件。

### 2.2. MVP核心交互流程

1.  **初始化**:
    *   应用启动，`PetWindow` 创建并显示。
    *   `SystemMonitor` 开始定期轮询系统参数。
    *   `Renderer` 加载初始的占位符桌宠图像（如IDLE状态）。

2.  **运行时循环**:
    *   `SystemMonitor` 获取最新的系统数据。
    *   `BehaviorLogic` 分析数据，判断是否需要改变桌宠状态。
    *   如果状态改变，`BehaviorLogic` 通知 `Renderer`。
    *   `Renderer` 从 `Resources` 获取新状态对应的动画帧（占位符），并在 `PetWindow` 上更新绘制。
    *   `PetWindow` 持续监听用户输入，交由 `InteractionHandler` 处理。
    *   如果 `StatsPanel` 可见，它会从 `SystemMonitor` 获取数据并更新显示。

3.  **用户交互 (示例：退出)**:
    *   用户在 `PetWindow` 上右键点击。
    *   `InteractionHandler` 捕获事件，显示包含"退出"选项的上下文菜单。
    *   用户选择"退出"，`InteractionHandler` 执行应用关闭逻辑。

*[图表占位: MVP核心模块交互图，待后续使用Graphviz在 `Diagrams/Architecture/mvp_architecture.py` 中创建]*

## 3. 技术选型 (MVP及后续规划)

-   **UI框架**: **PySide6** (Qt for Python) - 核心选择，负责所有GUI元素的创建、事件处理和渲染集成。
-   **系统信息获取**:
    -   `psutil`: 用于获取CPU、内存、磁盘I/O、网络I/O等跨平台系统信息。
    -   `GPUtil` (可选): 用于获取NVIDIA GPU的温度和使用率，按需集成。
-   **图像处理 (占位符阶段)**: PySide6 内建的 `QPixmap`, `QImage` 处理。若后续有复杂精灵图操作，可能考虑 `Pillow`。
-   **配置文件**: 简单配置可使用JSON格式 (`config.json`)。若配置复杂化，可考虑 `configparser` 或 YAML。
-   **数据持久化 (远期 - 桌宠记忆等)**: SQLite - 轻量级，适合桌面应用。
-   **测试框架**: Pytest - 配合 `pytest-qt` 进行PySide6 UI测试。
-   **打包与分发**: PyInstaller / cx_Freeze / Briefcase (待选型和测试)。

## 4. 占位符资源策略

-   MVP阶段，所有桌宠动画和应用图标将使用简单的占位符图像/序列帧图。
-   这些资源将存放于 `assets/placeholders/` 目录。
-   目的是快速验证核心功能逻辑，避免因美术资源制作瓶颈阻塞开发进度。
-   占位符应易于被真实美术资源替换。

## 5. 长远架构考量 (初步)

-   **模块化与插件化**: 核心系统设计时，应考虑接口的通用性和可扩展性，便于未来添加新的快捷功能、行为模式或集成外部服务（如LLM）作为独立模块或插件。
    * 已实现插件系统框架，支持插件的发现、加载、启用和卸载
    * 提供标准化的插件生命周期和依赖管理
    * 实现插件扩展点机制，支持不同类型的功能扩展
-   **事件驱动**: 可以考虑引入更明确的内部事件总线机制（如基于`signal`库或自定义实现），以解耦模块间的直接依赖，特别是对于复杂的行为触发和UI更新。
    * 已实现增强的事件系统，支持优先级、过滤和节流
    * 提供同步和异步事件处理机制
    * 标准化系统事件类型定义
-   **配置分离**: 将用户可配置的参数（如监控刷新率、桌宠行为阈值、UI主题色等）外部化到配置文件中。

## 6. 设计决策与理由 (部分)

-   **选择PySide6**: Qt框架功能完善，跨平台性好，社区成熟。PySide6作为官方绑定，与Python结合紧密。
-   **MVP聚焦核心监控反馈**: 确保项目在初期有一个清晰、可达成的目标，快速验证核心价值。
-   **占位符先行**: 降低初期美术门槛，使开发可以并行。
-   **插件系统设计**: 采用生命周期管理模式，确保插件在加载和卸载过程中的稳定性，同时提供良好的依赖管理和配置处理。
-   **事件系统增强**: 实现基于优先级的事件处理，使关键事件能够得到优先处理；添加事件过滤和节流机制，有效控制高频事件的处理效率。

## 7. 模块化框架

### 7.1 插件系统

Status-Ming 的插件系统旨在提供一个灵活、可扩展的框架，允许第三方开发者为应用添加新功能，而无需修改核心代码。

#### 插件系统核心组件

1. **PluginBase (抽象基类)**
   - **职责**: 定义所有插件必须实现的接口和生命周期方法
   - **主要方法**:
     - `load()`: 加载插件资源和初始化，但不激活功能
     - `enable()`: 启用插件功能，注册事件监听器、添加UI元素等
     - `disable()`: 禁用插件功能，但不释放资源
     - `unload()`: 卸载插件并释放所有资源
   - **属性**:
     - 基本信息: ID、名称、版本、描述
     - 依赖管理: 依赖项列表
     - 配置管理: 插件配置

2. **PluginManager (单例管理器)**
   - **职责**: 管理插件的发现、加载、启用和卸载
   - **主要功能**:
     - 插件发现: 扫描插件目录，找到并加载插件
     - 生命周期管理: 控制插件的加载、启用、禁用和卸载
     - 依赖解析: 处理插件之间的依赖关系
     - 配置管理: 处理插件配置的存储和检索

3. **PluginRegistry (插件注册表)**
   - **职责**: 管理插件类型和扩展点
   - **主要功能**:
     - 插件类型注册: 将插件与特定类型关联
     - 扩展点管理: 提供注册和使用扩展点的机制
     - 扩展实现管理: 跟踪哪些插件实现了哪些扩展点

#### 插件生命周期

插件生命周期由以下阶段组成:

1. **发现**: PluginManager扫描插件目录，找到可用插件
2. **加载**: 调用`load()`方法初始化插件资源和内部状态
3. **启用**: 调用`enable()`方法激活插件功能
4. **禁用**: 调用`disable()`方法停用插件功能
5. **卸载**: 调用`unload()`方法释放插件资源

#### 插件依赖管理

- 插件可以声明对其他插件的依赖
- PluginManager确保依赖项在加载和启用时遵循正确的顺序
- 提供防止循环依赖的保护机制

#### 插件配置管理

- 每个插件可以有自己的配置
- 配置通过PluginManager统一管理
- 支持配置的读取、写入和默认值

### 7.2 增强的事件系统

Status-Ming的事件系统是一个强大的基于发布-订阅模式的机制，用于应用内部模块间的解耦通信，经过增强后，提供了更多强大功能。

#### 事件系统核心组件

1. **EventManager (单例管理器)**
   - **职责**: 管理事件的分发和处理
   - **主要功能**:
     - 事件注册: 注册事件类型
     - 事件订阅: 注册事件处理器
     - 事件发布: 分发事件到订阅者
     - 异步处理: 支持异步事件处理

2. **EventSubscription (订阅信息)**
   - **职责**: 存储事件订阅的详细信息
   - **属性**:
     - 处理器: 事件处理函数
     - 事件类型: 订阅的事件类型
     - 优先级: 处理的优先级
     - 过滤器: 事件过滤条件
     - 节流设置: 控制事件处理频率

#### 事件优先级系统

事件优先级分为五个级别:
- **HIGHEST**: 最高优先级，首先处理
- **HIGH**: 高优先级
- **NORMAL**: 标准优先级(默认)
- **LOW**: 低优先级
- **LOWEST**: 最低优先级，最后处理

优先级确保关键事件（如错误处理）总是优先于非关键事件（如UI更新）处理。

#### 事件过滤机制

- 支持多重过滤条件组合
- 过滤器为可调用对象，接收事件类型和数据，返回布尔值
- 只有通过所有过滤条件的事件才会被处理

#### 事件节流机制

提供三种节流模式，用于控制高频事件:
- **FIRST**: 在指定时间段内只处理第一个事件，忽略后续事件
- **LAST**: 在指定时间段内只处理最后一个事件，丢弃中间事件
- **RATE**: 以固定速率处理事件，控制处理频率

#### 异步事件处理

- 支持将事件处理放入后台线程进行
- 使用线程池优化并发处理性能
- 提供事件队列和异步处理线程

#### 标准事件类型

定义了一系列标准系统事件类型，包括:
- 应用程序事件 (启动、退出)
- 系统事件 (错误、警告、信息)
- 插件事件 (加载、启用、禁用、卸载)
- 配置事件 (配置更改)

#### 7.2.1 事件系统迁移与兼容层

当前项目同时存在两个事件系统：

1. **旧事件系统** (`status/core/event_system.py`):
   - 基于枚举类型的 `EventType`
   - 使用 `Event` 类封装事件数据
   - 通过 `EventSystem` 类分发事件

2. **新增强事件系统** (`status/events/event_manager.py`):
   - 基于字符串的 `EventType`
   - 使用字典 `Dict[str, Any]` 表示事件数据
   - 提供更丰富的事件处理功能（优先级、过滤、节流、异步）

为确保项目稳定性和平滑迁移，我们实现了以下兼容策略：

1. **兼容层** (`status/core/events.py`):
   - 提供 `EventManager` 类，继承自旧系统的 `EventSystem`
   - 保持兼容旧系统的API，使现有代码继续工作
   - 为新类型的事件提供桥接机制

2. **渐进式迁移计划**:
   - 第一阶段(当前): 两系统共存，新功能使用新事件系统
   - 第二阶段: 逐步将旧系统事件映射到新系统，更新依赖旧系统的代码
   - 第三阶段: 淘汰旧事件系统，将兼容层转为新事件系统的门面

3. **开发规范**:
   - 新组件和插件应使用新事件系统 (`status/events/event_manager.py`)
   - 维护旧组件时，尽可能将事件处理逻辑迁移到新系统
   - 使用兼容层进行过渡，确保系统稳定

此迁移策略确保了系统的稳定性，同时允许代码库逐步现代化和模块化。

### 7.3 整合与扩展

- **插件与事件系统整合**: 插件可以订阅和发布事件，实现松耦合的功能扩展
- **扩展点与事件**: 扩展点可以使用事件机制进行通知和协调
- **未来扩展**: 计划添加更多标准扩展点，如UI扩展、命令扩展等

---
*本文档将随着项目进展和设计细化持续更新。* 